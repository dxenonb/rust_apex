// num = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ (^"e" ~ int)? }
//     int = { ("+" | "-")? ~ ASCII_DIGIT+ }

// operation = _{ add | subtract | multiply | divide | power }
//     add      = { "+" }
//     subtract = { "-" }
//     multiply = { "*" }
//     divide   = { "/" }
//     power    = { "^" }

// expr = { term ~ (operation ~ term)* }
// term = _{ num | "(" ~ expr ~ ")" }


class_file = _{ SOI ~ class ~ EOI }

class = 
    { annotation* 
    ~ class_access_mod? ~ class_def_mod? ~ "class" ~ ident
        ~ "{" 
        ~ class_body
        ~ "}" 
    }

class_access_mod = _{ access_mod }
class_def_mod = @{ "abstract" | "virtual" | "with sharing" | "without sharing" }
class_body = _{ class_item* }
class_item = { field | constructor | method }

constructor = { method_access_mod? ~ ident ~ method_args ~ method_body }
method = 
    { annotation?
    ~ method_access_mod? ~ "static"? ~ (^"testmethod")? ~ type_name ~ ident ~ method_args 
        ~ method_body 
    }
method_access_mod = _{ access_mod }
method_args = { "(" ~ method_args_list? ~ ")" }
method_args_list = _{ (method_arg ~ ",")* ~ method_arg }
method_arg = { type_name ~ ident }
method_body = { "{" ~ statement* ~ "}" }

// TODO: Allow initial assignment
// TODO: getters/setters
field = 
    { field_access_mod? ~ field_modifiers ~ type_name ~ ident 
    ~ (("=" ~ expr) | ";")
    }
field_access_mod = _{ access_mod }
field_modifiers = { ("static" | "final")* }
annotation = { "@" ~ ident ~ annotation_arg? }
annotation_arg = { "(" ~ ident ~ "=" ~ literal ~ ")" }

access_mod = @{ "public" | "private" | "global" }

statement = 
    { 
        ( statement_return
        | statement_dml
        | statement_decl
        | expr
        )
    ~ ";" 
    }
statement_return = { "return" ~ expr }
statement_decl = { type_name ~ ident ~ ("=" ~ expr)? }
// TODO: dml_upsert
statement_dml = { ("insert" | "update" | "delete") ~ expr }

// TODO: Verify precedence and adjust associativity
// TODO: pest's precedence climber is pry better...
expr = { expr_assignment }
expr_assignment = { expr_equality ~ (assign_op ~ expr_equality)* }
expr_equality = { expr_comparison ~ (eq_op ~ expr_comparison)* }
expr_comparison = { expr_multiplication ~ (comp_op ~ expr_multiplication)*  }
expr_multiplication = { expr_addition ~ (mul_op ~ expr_addition)* }
expr_addition = { expr_unary ~ (add_op ~ expr_unary)* }
expr_unary = { unary_op* ~ expr_primary }
expr_primary = { expr_new | literal | func_call | el_access | soql }
expr_new = { "new" ~ type_name ~ type_constructor_args }

assign_op = @{ ("+" | "-" | "*" | "/")? ~ "=" }
eq_op = @{ "!=" | "==" | "!==" | "===" }
comp_op = @{ "<" | ">" | "<=" | ">=" }
mul_op = @{ "*" | "/" }
add_op = @{ "+" | "-" }
unary_op = @{ "!" | "-" }

type_constructor_args = { list_initializer | sobject_field_args | func_args }

list_initializer = { "{" ~ list_init_args? ~ "}" }
list_init_args = { expr ~ ("," ~ expr)* }

// TODO: naming... this represents for example: "new Account(Name = 'Foo')";
sobject_field_args = { "(" ~ sobject_field_args_list? ~ ")" }
sobject_field_args_list = 
    { "(" 
    ~ sobject_field_arg
    ~ ("," ~ sobject_field_args)*
    ~ ")" 
    }
sobject_field_arg = { ident ~ "=" ~ expr }

type_name = { type_path ~ type_args? }
type_args = { "<" ~ type_name ~ ("," ~ type_name)* ~ ">" }
type_path = { el_access }

func_call = { el_access ~ func_args }
func_args = { "(" ~ func_args_list? ~ ")" }
func_args_list = { expr ~ ("," ~ expr)* }
el_access = { ident ~ ("." ~ ident)* }
ident = @{ !(keyword ~ WHITESPACE) ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
literal = @{ "null" | "true" | "false" | string | num }
num = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT* )? ~ "L"? }
string = { "'" ~ (raw_string | escape)* ~ "'" }
escape = { "\\" ~ ANY }
raw_string = { (!("\\" | "'") ~ ANY)+ }

keyword = @{ "new" }

// TODO: very TODO!
soql = { "[" ~ raw_soql ~ (soql ~ raw_soql?)* ~ "]" }
raw_soql = { (!("]" | "[") ~ ANY)* }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ comment }

comment = { line_comment | block_comment }

line_comment = { "//" ~ (!(NEWLINE) ~ ANY)* ~ NEWLINE }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }